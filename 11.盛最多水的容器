给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。



图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 【图片】

示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49

--------------------------------------------------------------------------
总体思路：
双指针

暴力：O（n2）
双指针：O（n）
主要思考如何移动双指针才能保证最大的盛水量被遍历到
结论是容器高度小的一个指针移动。
反证不能移动容器高度大的：
假设有左指针left和右指针right，且left指向的值小于right的值，假如我们将右指针左移，则右指针左移后的值和左指针指向的值相比有三种情况
	1.	右指针指向的值大于左指针 这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
	2.	右指针指向的值等于左指针 这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
	3.	右指针指向的值小于左指针 这种情况下，容器的高取决于右指针，但是右指针小于左指针，且底也变短了，所以容量盛水量一定变小了
综上所述，容器高度较大的一侧的移动只会造成容器盛水量减小
所以应当移动高度较小一侧的指针，并继续遍历，直至两指针相遇。

--------------------------------------------------------------------------


class Solution {
public:
    int maxArea(vector<int>& height) {
    	int ans = 0;
    	int temp = 0;
    	int left = 0;
    	int right = height.size()-1;
    	
        while(left<right){
        	ans = max(ans, (right-left) * min(height[left],height[right]));
        	if(height[left]>height[right]){
        		right--;
        	}else{
        		left++;
        	}
        }

        return ans;
    }
};
